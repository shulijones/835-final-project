<script src="https://unpkg.com/vue@3"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>


<div id="app">
  <h1>Picture Hanging Helper -- Prototype</h1>
  <h2>Developed by Shuli Jones and Emily Caragay</h2>

  <h3>Hang a picture perfectly in only five steps!</h3>
  <div id="steps">
    <button v-bind:class="{'active': step == 0}" v-on:click="changeStepMaybe(0)">
      Identify wall
    </button> <div class="arrow-right"></div>
  
    <button v-bind:class="{'active': step == 1}" v-on:click="changeStepMaybe(1)">
      Capture picture
    </button> <div class="arrow-right"></div>
    
    <button v-bind:class="{'active': step == 2}" v-on:click="changeStepMaybe(2)">
      Show hanging point
    </button>  <div class="arrow-right"></div>
   
    <button v-bind:class="{'active': step == 3}" v-on:click="changeStepMaybe(3)">
      Show hanging location
    </button> <div class="arrow-right"></div>
    
    <button v-bind:class="{'active': step == 4}" v-on:click="changeStepMaybe(4)">
      Place nail
    </button>
  </div>

  <div id="instructions">
    <h3> Instructions </h3>

    <p v-if="step == 0">
      <b>Step 1: Identify wall.</b> We need to know where you'll be hanging the picture!
      Position your computer so that the webcam shows all of the wall and say
      "save wall".
    </p>

    <p v-if="step == 1">
      <b>Step 2: Capture picture.</b> Show us what your picture looks like!
      Hold the picture up close to the camera so that all of it is visible and say 
      "capture picture".
    </p>

    <p v-if="step == 2">
      <b>Step 3: Show hanging point.</b> Tell us how your picture will hang!
      On the image of your picture below, drag the circle to where the nail will go and then 
      click save. Based on that information, and what you'll tell us in Step 4 about where
      the picture goes on the wall, we'll calculate the nail's location.
    </p>

    <p v-if="step == 3">
      <b>Step 4: Show hanging location.</b> Show us where your picture will hang!
      Hold your picture up to the wall right where you want it to go. Then say "save location".
      Then, come back here to match up your original picture to its location by dragging
      and resizing it. Click the "done" button when you're done.
    </p>

    <p v-if="step == 4">
      <b>Step 5: Place nail.</b> It's finally time to place the nail!
      Head on over to the wall with your bright green bottle cap in hand. The computer
      will help you place the nail, first horizontally, then vertically. Say "horizontal"
      to get started. The computer will tell you whether to move left or right, and let
      you know when you're all mtached up. Then, say "vertical" to repeat the process
      in the vertical direction. When you're done, you're done!
      Go ahead and hang your picture!
    </p>
  </div>

  <div id="video-feed" v-if="step != 2">
    <p>Your video:</p>
    <img :src=src_string>
  </div>

  <div v-if="step == 4">
    You need to move: {{ direction }}
  </div>



  <div id="image-display">
  </p> Here's what we have as your picture. (If it's not right, feel
      free to try again.) <p>
    <!-- <div v-if="wall">
      Your wall: <br>
      <img :src=wall>
    </div> -->
    
    <div v-if="capture_picture">
      Your picture: <br>
      <img :src=capture_picture>
    </div>

    <!-- <div v-if="hang_location">
      Your hanging location: <br>
      <img :src=hang_location>
    </div> -->
  </div>

  <button v-if="step == 3" v-on:click="savePictureLocationOnWall()">
    save picture location
  </button>
  
<div id="wall-img"  v-bind:class="{'visible': step == 3} ">
  WALL IMAGE
  <img :src=hang_location style="max-width:100%;
    max-height:100%;">
</div>

<div id="mydiv"  v-bind:class="{'visible': step == 3}">
  <!-- Include a header DIV with the same name as the draggable DIV, followed by "header" -->
  <div id="mydivheader">
    Click here to move
  </div>
  <div id = "poster">
    <img id = "actual-poster" :src=capture_picture style="width:100%;
    object-fit: cover; overflow: hidden;
    height:100%;">
  </div>
</div>


<button v-on:click="placeHangingPoint()" v-if="step == 2">
  place hanging point
</button>

<div id="placement-dot"  v-bind:class="{'active': step == 2}" ></div>

<div id = "poster-img"  v-if="step == 2">
  <img :src=capture_picture style="max-width:100%;
    max-height:100%;">
</div>

</div>


<script>
  Vue.createApp({
    data() {
      return {
        speech: '[No speech yet!]',
        wall: "",
        capture_picture: "",
        hang_location: "",
        step: 0,
        lastStepChange: Date.now(),
        direction: "",
        directions: {"L": "left", "R": "right",
                      "U": "up", "D": "down"},
        orientation: "horizontal"
      }
    },
    methods: {
      savePictureLocationOnWall() {
        var imgy = window.scrollY + 
            document.querySelector("#actual-poster").getBoundingClientRect().top // Y
        var imgx = window.scrollX + 
            document.querySelector('#actual-poster').getBoundingClientRect().left // X
        
        var wally = window.scrollY + 
            document.querySelector("#wall-img").getBoundingClientRect().top;
        var wallx = window.scrollX + 
            document.querySelector("#wall-img").getBoundingClientRect().left;

        console.log(imgy, imgx, wally, wallx)
        console.log('frame corner', {'x': wallx - imgx, 'y': wally - imgy})
        axios.post('http://localhost:8080/api/frame_corner', 
                  {'x': imgx - wallx, 'y': imgy - wally})
      },

      placeHangingPoint() {
        var imgy = window.scrollY + 
            (document.querySelector("#placement-dot").getBoundingClientRect().top
            +document.querySelector("#placement-dot").getBoundingClientRect().bottom)/2 // Y
        var imgx = window.scrollX + 
            (document.querySelector('#placement-dot').getBoundingClientRect().left
            +document.querySelector("#placement-dot").getBoundingClientRect().right)/2 // X
        
        var wally = window.scrollY + 
            document.querySelector("#poster-img").getBoundingClientRect().top;
        var wallx = window.scrollX + 
            document.querySelector("#poster-img").getBoundingClientRect().left;

        console.log(imgy, imgx, wally, wallx)
        console.log('hanging point', {'x': wallx - imgx, 'y': wally - imgy})
        axios.post('http://localhost:8080/api/hanging_point', 
                  {'x': imgx - wallx, 'y': imgy - wally})
      },
      changeStepMaybe(newStep) {
        // allows you to go back any number of steps and advance one step
        // clicking on current step changes nothing, advancing more than one step
        // raises an alert and changes nothing
        if (newStep == this.step) {
          return; // do nothing
        } else if (newStep == this.step + 1) {
          this.step += 1; // advance one step
        } else if (newStep < this.step) {
          // raise alert to make sure they want to go back and lose progress
          let conf = confirm("This step is before your current step." +
                  " If you go backwards, your intermediate progress will be lost.");
          console.log(conf)
          if (conf) {
            this.step = newStep;
          }
        } else {
          alert("You can't switch to that step -- it's too far ahead." + 
                " Complete the intermediate step(s) first.")
        }
      },
      speak(utterance) { 
        let utt = new SpeechSynthesisUtterance(utterance);
        speechSynthesis.speak(utt);
      },
      getDirection() {
        if (this.step == 4) {
          axios.get('http://localhost:8080/api/direction/' + this.orientation)
            .then((response) => {
              const result = response.data
              console.log('got direction response and it was: ', result)
              if (result == "error") {
                console.log("the backend returned the word 'error'")
              }
              else if (result == "P") {
                this.speak("You're all done with this orientation!")
              } else if (result in this.directions) {
                this.direction = this.directions[result]
                this.speak(this.direction)
              } else {
                console.log("the backend returned something unusual")
              }
            })
            .catch((error) => {
              console.log(error)
            });
        }
      }
    },
    computed: {
      src_string() {
         return this.step == 4 ? 'http://localhost:8080/api/video_feed_color' 
                                : 'http://localhost:8080/api/video_feed'
      },
    },
    mounted() {
      // Start the function which will continously do nail positioning when in step 4
      // every 5 seconds right now
      setInterval(this.getDirection, 2000)

      // Set up Speech Recognition
      var recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.onresult = (event) => { 
        // note: arrow function syntax is crucial so that 'this' keeps larger scope
        this.speech = event.results[event.results.length-1][0].transcript.toLowerCase();
        
        // only advance to next step if it's been 0.1 sec or more
        // since last advancing (to prevent same speech being recognized
        // multiple times)
        if (this.speech.includes("next step") && 
              this.lastStepChange < Date.now() - 100) { 

          this.step += 1;
          this.lastStepChange = Date.now();
          recognition.stop();
          this.speak("Advancing to step " + this.step);

        } else if (this.speech.includes("save wall")) {
          axios.get('http://localhost:8080/api/get_video_frame_wall')
            .then((response) => {
              this.wall = "data:image/jpg;base64," + response.data
            })
            .catch((error) => {
              console.log(error)
            });
        } else if (this.speech.includes("capture picture")) {
          axios.get('http://localhost:8080/api/get_picture')
            .then((response) => {
              this.capture_picture = "data:image/jpg;base64," + response.data
            })
            .catch((error) => {
              console.log(error)
            });
        } else if (this.speech.includes("save location")) {
          axios.get('http://localhost:8080/api/get_video_frame_location')
            .then((response) => {
              this.hang_location = "data:image/jpg;base64," + response.data
            })
            .catch((error) => {
              console.log(error)
            });
        } else if (this.speech.includes("vertical")) {
          this.orientation = 'vertical'
        }
      }
      recognition.onend = function(event) {
        setTimeout(function() {
          recognition.start();
        }, 1000);
      };
      recognition.start();
    }
  }).mount('#app')
</script>

<style>
  #steps {
    display: flex;
    align-items: center;
  }

  #steps > button {
    background-color: lightblue;
    padding: 10px;
    margin: 0;
    border: 1px solid black;
    border-radius: 5px;
  }

  .arrow-right {
      width: 0; 
      height: 0; 
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 10px solid blue;
      margin: 2px;
  }

  .active {
    background-color: lightgreen !important; 
  }

  .visible{
    visibility: visible !important;
}

  }

  .not-visible{
    visibility: hidden !important;
  }

  #poster{
      /* background-image: url("poster.jpg");
      background-size: contain; */
      width: 100px;
      height: 100px;
      
    resize: both;
    overflow: hidden;
  }

  #wall-img{
    width: 500px;
    height: auto;
    opacity: 50%;
    visibility:hidden;

  }
  #poster-img{
    width: 500px;
    height: auto;
    opacity: 50%;
  }

  #mydiv {
    position: absolute;
    z-index: 9;
    visibility: hidden;

}

#placement-dot {
    position: absolute;
    z-index: 9;
    height: 25px;
    width: 25px;
    background-color: transparent;
    border-radius: 50%;
    display: inline-block;

}

#image-display {
    display: flex;
    flex-direction: column;
  }

  #image-display > div {
    margin: 10px;
  }
</style>


<script>
  dragElement(document.getElementById("mydiv"));

  dragElement(document.getElementById("placement-dot"));
function dragElement(elmnt) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  if (document.getElementById(elmnt.id + "header")) {
    // if present, the header is where you move the DIV from:
    document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
  } else {
    // otherwise, move the DIV from anywhere inside the DIV:
    elmnt.onmousedown = dragMouseDown;
  }

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

</script>


