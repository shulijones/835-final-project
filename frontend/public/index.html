<script src="https://unpkg.com/vue@3"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="confetti.js"></script>
<!-- Bootstrap (CSS package) -->
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous"> -->
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap-theme.min.css" integrity="sha384-6pzBo3FDv/PJ8r2KRkGHifhEocL+1X2rVCTTkUfGk7/0pbek5mMa1upzvWbrUbOZ" crossorigin="anonymous"> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script> -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

<div id="app">
  <div id="header">
    <h1>Picture Hanging Helper</h1>
    <h3>Hang a picture in only five steps!</h3>
    <div id="steps">
      <button type="button" class="btn" v-bind:class="{'btn-success': step == 0, 'btn-outline-primary': step != 0}" v-on:click="changeStepMaybe(0)">
        0. Read instructions
      </button> <div class="arrow-right"></div>

      <button type="button" class="btn" v-bind:class="{'btn-success': step == 1, 'btn-outline-primary': step != 1}" v-on:click="changeStepMaybe(1)">
        1. Capture picture
      </button> <div class="arrow-right"></div>
      
      <button type="button" class="btn" v-bind:class="{'btn-success': step == 2, 'btn-outline-primary': step != 2}" v-on:click="changeStepMaybe(2)">
        2. Hanging point
      </button>  <div class="arrow-right"></div>
    
      <button type="button" class="btn" v-bind:class="{'btn-success': step == 3, 'btn-outline-primary': step != 3}" v-on:click="changeStepMaybe(3)">
        3. Hanging location
      </button> <div class="arrow-right"></div>
      
      <button type="button" class="btn" v-bind:class="{'btn-success': step == 4, 'btn-outline-primary': step != 4}" v-on:click="changeStepMaybe(4)">
        4. Place picture
      </button> <div class="arrow-right"></div>
      
      <button type="button" class="btn" v-bind:class="{'btn-success': step == 5, 'btn-outline-primary': step != 5}" v-on:click="changeStepMaybe(5)">
        5. Place nail
      </button>
    </div>
  </div>

  <div id="app-body">
  <div id="instructions">
    <p v-if="step == 0">
      This is the instructions for all five steps; each step also shows its own instructions. 
      You can move between steps by clicking on their names or by saying "next step" out loud.
    </p>

    <p v-if="step == 1 || step == 0">
      <b>Step 1: Capture picture.</b>
      Hold the picture so that it fills as much of the screen as possible and say 
      "capture picture". Hold the picture still for three seconds.
      You can repeat this step until you get a picture you're happy with.
    </p>

    <p v-if="step == 2 || step == 0">
      <b>Step 2: Hanging point.</b>
      On the image of your picture below, drag the circle to where the nail will go and 
      click save. Based on that information, and what you'll tell us in Step 4 about where
      the picture goes on the wall, we'll calculate the nail's location.
    </p>

    <p v-if="step == 3 || step == 0">
      <b>Step 3: Hanging location.</b> 
      Hold your picture up to the wall where you want it to go. Then say "save location".
      Once you have saved the location, don't move your computer for the rest 
      of the process.
    </p>

    <p v-if="step == 4 || step == 0">
      <b>Step 4: Place picture. </b> Match up your picture to its 
      location by dragging and resizing it, then click "save". You can adjust its location
      from the original if you prefer;
      the computer will place the nail based on the location where you drag the picture,
      not where it is in the original photo.
    </p>


    <p v-if="step == 5 || step == 0">
      <b>Step 5: Place nail.</b> 
      Stand by the wall with your colored marking object (ex: a bottle cap). We recommend green, blue, or purple for best results.
      You can say 'horizontal' or 'vertical' and the computer will tell you whether to move left/right or up/down. 
      It will also let you know when you're correctly oriented in each direction. Once both
      directions are done, your picture is ready to hang up!
    </p>

    <div v-if="step == 5" >
      Select the color of your marking object:
      <br>
      <input type="color" id="colorpicker" value="#0000ff">
      <br>
      <button type="button" class="btn btn-secondary" v-on:click="sendColorCode()">
        Save color selection
      </button>
    </div>
    
  </div>

  <button type="button" class="btn btn-secondary" v-if="step == 4" v-on:click="savePictureLocationOnWall()">
    Save picture location
  </button>

  <div v-if="capture_picture && step == 1">
    <br>
    <p> 
      Here's what we have as your picture. If it's not right, feel
      free to try again. If nothing appears, try making sure all the picture's
      edges are visible and try again.
    </p>
    
    <img :src=capture_picture style="width:250px">
  </div>

  <div id="video-feed" v-if="step != 2 && step != 0 && step != 4">
    <p>Your video:</p>
    <img :src=src_string style=" transform: scaleX(-1)">
  </div>

  <div v-if="step == 5">
    You need to move: {{ direction }}
  </div>


  <div v-if="hang_location && step == 3">
    Your hanging location: <br>
    <img :src=hang_location>
  </div>

  
<div id="wall-img"  v-bind:class="{'visible': step == 4} ">
  <img :src=hang_location>
</div>



  <div id="mydiv"  v-bind:class="{'visible': step == 4}">
    <!-- Include a header DIV with the same name as the draggable DIV, followed by "header" -->
    <div id="mydivheader">
      [Click and drag here to move the image]
    </div>
    <div id = "poster">
      <img id = "actual-poster" :src=capture_picture style="max-width:100%;
      height:100%;">
    </div>
  </div>

  <button type="button" class="btn btn-secondary" v-on:click="placeHangingPoint()" v-if="step == 2">
    Save hanging point
  </button>

  <div id="placement-dot"  v-bind:class="{'active': step == 2}" ></div>

  <div id = "poster-img"  v-if="step == 2">
    <img :src=capture_picture style="width: 400px; max-width:100%;
      max-height:100%;">
  </div>
</div>

</div>


<script>
  Vue.createApp({
    data() {
      return {
        speech: '[No speech yet!]',
        wall: "",
        capture_picture: "",
        hang_location: "",
        step: 0,
        lastStepChange: Date.now(),
        direction: "",
        directions: {"L": "left", "R": "right",
                      "U": "up", "D": "down"},
        orientation: "",
        orientationDone: false,
      }
    },
    methods: {
      test() {
        axios.get('http://localhost:8080/api/get_picture')
            .then((response) => {
              this.capture_picture = "data:image/jpg;base64," + response.data
            })
            .catch((error) => {
              console.log("error while getting picture: ", error)
            });
      },
      savePictureLocationOnWall() {
        var imgy = window.scrollY + 
            document.querySelector("#actual-poster").getBoundingClientRect().top // Y
        var imgx = window.scrollX + 
            document.querySelector('#actual-poster').getBoundingClientRect().left // X
        
        var wally = window.scrollY + 
            document.querySelector("#wall-img").getBoundingClientRect().top;
        var wallx = window.scrollX + 
            document.querySelector("#wall-img").getBoundingClientRect().left;

        axios.post('http://localhost:8080/api/frame_corner', 
                  {'x': imgx - wallx, 'y': imgy - wally})
        alert("Your picture location has been saved. You can move to the next step.")  
      },

      placeHangingPoint() {
        var imgy = window.scrollY + 
            (document.querySelector("#placement-dot").getBoundingClientRect().top
            +document.querySelector("#placement-dot").getBoundingClientRect().bottom)/2 // Y
        var imgx = window.scrollX + 
            (document.querySelector('#placement-dot').getBoundingClientRect().left
            +document.querySelector("#placement-dot").getBoundingClientRect().right)/2 // X
        
        var wally = window.scrollY + 
            document.querySelector("#poster-img").getBoundingClientRect().top;
        var wallx = window.scrollX + 
            document.querySelector("#poster-img").getBoundingClientRect().left;

        // TODO: hanging point is currently absolute which doesn't work
        // since image is resized from original, need to make it percentage-based
        // and then figure out how to integrate that on backend
        var wall_height = document.querySelector("#poster-img").getBoundingClientRect().bottom
            - document.querySelector("#poster-img").getBoundingClientRect().top;
        var wall_width = document.querySelector("#poster-img").getBoundingClientRect().right
            - document.querySelector("#poster-img").getBoundingClientRect().left;
        
        var dx = imgx - wallx;
        var dy = imgy - wally;
        var xp = dx / wall_width;
        var yp = dy / wall_height;

        axios.post('http://localhost:8080/api/hanging_point', 
                  {'x': imgx - wallx, 'y': imgy - wally})
        alert("Your hanging point has been saved. You can move to the next step.")
      },
      sendColorCode(){
        color_code = document.getElementById("colorpicker").value;
        axios.post('http://localhost:8080/api/select_tracking_color', 
                  {'color': color_code})
        alert("Your color selection has been updated!")  
      },
      changeStepMaybe(newStep) {
        // allows you to go back any number of steps and advance one step
        // clicking on current step changes nothing, advancing more than one step
        // raises an alert and changes nothing
        if (newStep == this.step) {
          return; // do nothing
        } else if (newStep == this.step + 1) {
          this.step += 1; // advance one step
        } else if (newStep < this.step) {
          // raise alert to make sure they want to go back and lose progress
          let conf = confirm("This step is before your current step." +
                  " If you go backwards, your intermediate progress will be lost.");
          if (conf) {
            if (this.step == 5) {
              // if the user is going backward from step 5,
              // stop any confetti they might have had
              stopConfetti();
            }
            this.step = newStep;
          }
        } else {
          alert("You can't switch to that step -- it's too far ahead." + 
                " Complete the intermediate step(s) first.")
        }
      },
      speak(utterance) { 
        let utt = new SpeechSynthesisUtterance(utterance);
        // utt.voice = window.speechSynthesis.getVoices()[3];
        speechSynthesis.speak(utt);
      },
      getDirection() {
        if (this.step == 5 && !this.orientationDone && 
                (this.orientation == 'vertical' || this.orientation == 'horizontal')) {
          axios.get('http://localhost:8080/api/direction/' + this.orientation)
            .then((response) => {
              const result = response.data
              if (result == "error") {
                console.log("the backend returned the word 'error'")
              }
              else if (result == "P") {
                this.orientationDone = true;
                startConfetti();
                this.speak("You're correctly aligned! You can now hang your picture.")
              } else if (result == "S") {
                this.orientationDone = true;
                this.speak("You're correctly aligned in the " + this.orientation +
                    " direction only. Switch to the other direction to finish.")
              } else if (result in this.directions) {
                this.direction = this.directions[result]
                this.speak(this.direction)
              } else {
                console.log("the backend returned something unusual")
              }
            })
            .catch((error) => {
              console.log("error while getting direction: ", error)
            });
        }
      }
    },
    computed: {
      src_string() {
         return this.step == 5 ? 'http://localhost:8080/api/video_feed_color' 
                                : 'http://localhost:8080/api/video_feed'
      },
    },
    mounted() {
      // Start the function which will continously do nail positioning when in step 4
      // every 5 seconds right now
      setInterval(this.getDirection, 2000)

      // Set up Speech Recognition
      var recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.onresult = (event) => { 
        // note: arrow function syntax is crucial so that 'this' keeps larger scope
        this.speech = event.results[event.results.length-1][0].transcript.toLowerCase();
        
        // only advance to next step if it's been 0.1 sec or more
        // since last advancing (to prevent same speech being recognized
        // multiple times)
        if (this.speech.includes("next step") && 
              this.lastStepChange < Date.now() - 100) { 

          this.step += 1;
          this.lastStepChange = Date.now();
          recognition.stop();
          this.speak("Advancing to step " + this.step);

        } else if (this.speech.includes("capture picture")) {
          axios.get('http://localhost:8080/api/get_picture')
            .then((response) => {
              this.capture_picture = "data:image/jpg;base64," + response.data
            })
            .catch((error) => {
              console.log("error while getting picture: ", error)
            });
        } else if (this.speech.includes("save location")) {
          axios.get('http://localhost:8080/api/get_video_frame_location')
            .then((response) => {
              this.hang_location = "data:image/jpg;base64," + response.data
              this.speak("Location saved")
            })
            .catch((error) => {
              console.log("error while getting video frame: ", error)
            });
        } else if (this.speech.includes("vertical")) {
          this.orientation = 'vertical'
          this.orientationDone = false;
        } else if (this.speech.includes("horizontal")) {
          this.orientation = 'horizontal'
          this.orientationDone = false;
        }
      }
      recognition.onend = function(event) {
        setTimeout(function() {
          recognition.start();
        }, 1000);
      };
      recognition.start();
    }
  }).mount('#app')
</script>

<style>
  #app {
    margin: 30px 50px 50px 50px;
  }

  #steps {
    display: flex;
    align-items: center;
  }

  #steps > .btn {
    margin: 0px 3px 0px 3px;
  }

  .btn:focus {
     outline: none !important;
  } 

  .btn-secondary {
    margin: 10px 0px 5px 0px;
  }

  .arrow-right {
      width: 0; 
      height: 0; 
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 10px solid #0033cc;
      margin: 2px;
  }

  #instructions {
    font-size: 125%;
  }

  #app-body {
    width: 70%;
    margin: 20px 0px 0px 30px;
  }

  .visible{
    visibility: visible !important;
  }

  .not-visible{
    visibility: hidden !important;
  }

  .active{
    background-color: green !important;
  }

  #poster{
      /* background-image: url("poster.jpg");
      background-size: contain; */
      width: 100px;
      height: 100px;
      
    resize: both;
    overflow: hidden;
  }

  #wall-img{
    width: 500px;
    height: auto;
    opacity: 50%;
    visibility:hidden;

  }
  #poster-img{
    width: 500px;
    height: auto;
    opacity: 50%;
  }

  #mydiv {
    position: absolute;
    z-index: 9;
    visibility: hidden;

  }

  #placement-dot {
      position: absolute;
      z-index: 9;
      height: 25px;
      width: 25px;
      background-color: transparent;
      border-radius: 50%;
      display: inline-block;

  }

  #image-display {
      display: flex;
      flex-direction: column;
  }

  #image-display > div {
    margin: 10px;
  }
</style>


<script>
  dragElement(document.getElementById("mydiv"));

  dragElement(document.getElementById("placement-dot"));
function dragElement(elmnt) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  if (document.getElementById(elmnt.id + "header")) {
    // if present, the header is where you move the DIV from:
    document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
  } else {
    // otherwise, move the DIV from anywhere inside the DIV:
    elmnt.onmousedown = dragMouseDown;
  }

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

</script>


