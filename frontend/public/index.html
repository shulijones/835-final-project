<script src="https://unpkg.com/vue@3"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>


<div id="app">
  <h1>Picture Hanging Helper -- Prototype</h1>
  <h2>Developed by Shuli Jones and Emily Caragay</h2>
  <div id="steps">
    <button v-bind:class="{'active': step == 0}" v-on:click="changeStepMaybe(0)">
      Identify wall
    </button> <div class="arrow-right"></div>
  
    <button v-bind:class="{'active': step == 1}" v-on:click="changeStepMaybe(1)">
      Capture picture
    </button> <div class="arrow-right"></div>
    
    <button v-bind:class="{'active': step == 2}" v-on:click="changeStepMaybe(2)">
      Show hanging point
    </button>  <div class="arrow-right"></div>
   
    <button v-bind:class="{'active': step == 3}" v-on:click="changeStepMaybe(3)">
      Show hanging location
    </button> <div class="arrow-right"></div>
    
    <button v-bind:class="{'active': step == 4}" v-on:click="changeStepMaybe(4)">
      Place nail
    </button>
  </div>
  <p>What we just heard you say: {{ speech }}</p>

  <div id="video-feed" v-if="step != 2">
    <p>Your video:</p>
    <img :src=src_string>
  </div>
  
  <div v-if="single_image">
    Your picture:
    <img :src=single_image>
  </div>
  
  
  <p>To take a picture of your current video
    and save the picture frame you're holding up, say "take a picture".
    To switch to color tracking mode, say "color". To switch to default mode
    (no color tracking), say "default". 
  </p>
  <button  v-on:click="test()">
    Place nail
  </button>
  
<div id = "wall-img">
  <img src="held_to_wall.jpg" style="max-width:100%;
    max-height:100%;">
</div>
<div id="mydiv">
  <!-- Include a header DIV with the same name as the draggable DIV, followed by "header" -->
  <div id="mydivheader">
    Click here to move
  </div>
  <div id = "poster">
    <img id = "actual-poster" src="poster.jpg" style="max-width:100%;
    max-height:100%;">
  </div>
</div>

</div>




<script>
  Vue.createApp({
    data() {
      return {
        speech: '[No speech yet!]',
        single_image: "",
        step: 0,
        testvar: Date.now(),
      }
    },
    methods: {
      test() {
        var x = window.scrollY + document.querySelector("#actual-poster").getBoundingClientRect().top // Y

        var y = window.scrollX + document.querySelector('#actual-poster').getBoundingClientRect().left // X
        var y_r = window.scrollX + document.querySelector('#actual-poster').getBoundingClientRect().right// X
        console.log(x,y,y_r)
      },
      changeStepMaybe(newStep) {
        // allows you to go back any number of steps and advance one step
        // clicking on current step changes nothing, advancing more than one step
        // raises an alert and changes nothing
        if (newStep == this.step) {
          return; // do nothing
        } else if (newStep == this.step + 1) {
          this.step += 1; // advance one step
        } else if (newStep < this.step) {
          // raise alert to make sure they want to go back and lose progress
          let conf = confirm("This step is before your current step." +
                  " If you go backwards, your intermediate progress will be lost.");
          console.log(conf)
          if (conf) {
            this.step = newStep;
          }
        } else {
          alert("You can't switch to that step!")
        }
      },
      // speak(utterance){ 
      //   let utt = new SpeechSynthesisUtterance(utterance);
      //   speechSynthesis.speak(utt);
      // }
    },
    computed: {
      src_string() {
         return this.step == 4 ? 'http://localhost:8080/api/video_feed_color' : 'http://localhost:8080/api/video_feed'
      }
    },
    mounted() {
      var recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.onresult = (event) => { 
        // note: arrow function syntax is crucial so that 'this' keeps larger scope
        this.speech = event.results[event.results.length-1][0].transcript.toLowerCase();
        
        // console.log("HI", this.testvar)
        if (this.speech.includes("next step") ){ // && this.testvar
          this.step += 1;
          //this.testvar = false;
          // console.log('test1', this.testvar)

          recognition.stop();
          // this.testvar = true; doesnt work
          // this.speak("Advancing to next step");
        } else if (this.speech.includes("take picture") ||
                  this.speech.includes("take a picture") ) {
          axios.get('http://localhost:8080/api/get_picture')
            .then((response) => {
              this.single_image = "data:image/jpg;base64," + response.data
            })
            .catch((error) => {
              console.log(error)
            });
        }

        // if (this.mode != this.mode_old){
          // let utterance = new SpeechSynthesisUtterance("Switched Mode");
          // speechSynthesis.speak(utterance);
        //   this.mode_old = this.mode
        // }
      }
      recognition.onend = function(event) {
        setTimeout(function() {
          recognition.start();
        }, 1000);
      };
      recognition.start();
    }
  }).mount('#app')
</script>

<style>
  #steps {
    display: flex;
    align-items: center;
  }

  #steps > button {
    background-color: lightblue;
    padding: 10px;
    margin: 0;
    border: 1px solid black;
    border-radius: 5px;
  }

.arrow-right {
    width: 0; 
    height: 0; 
    border-top: 10px solid transparent;
    border-bottom: 10px solid transparent;
    border-left: 10px solid blue;
    margin: 2px;
}

  .active {
    background-color: lightgreen !important; 
  }


  #poster{
      /* background-image: url("poster.jpg");
      background-size: contain; */
      width: 100px;
      height: 100px;
      
    resize: both;
    overflow: hidden;
  }

  #wall-img{
    width: 500px;
    height: auto;
    opacity: 50%;
  }

  #mydiv {
    position: absolute;
    z-index: 9;

}
</style>


<script>
  dragElement(document.getElementById("mydiv"));

function dragElement(elmnt) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  if (document.getElementById(elmnt.id + "header")) {
    // if present, the header is where you move the DIV from:
    document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
  } else {
    // otherwise, move the DIV from anywhere inside the DIV:
    elmnt.onmousedown = dragMouseDown;
  }

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

</script>

